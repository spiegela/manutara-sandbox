package client

import (
	"errors"
	"log"
	"strings"

	"github.com/sirupsen/logrus"

	"github.com/spiegela/manutara/pkg/service/client/csrf"

	"github.com/emicklei/go-restful"
	authAPI "github.com/spiegela/manutara/pkg/service/auth/api"
	"github.com/spiegela/manutara/pkg/service/client/api"
	authv1 "k8s.io/api/authorization/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	cmdAPI "k8s.io/client-go/tools/clientcmd/api"
)

// MsgLoginUnauthorizedError is the reason key for an unauthorized error
const MsgLoginUnauthorizedError = "MSG_LOGIN_UNAUTHORIZED_ERROR"

// Version is the version of the client
var Version = "UNKNOWN"

// Client structures and interfaces are adapted from Kubernetes
// dashboard:
// https://github.com/kubernetes/dashboard/blob/master/src/app/backend/client/manager.go

// clientManager implements ClientManager interface
type clientManager struct {
	// Autogenerated key on backend start used to secure requests from csrf
	// attacks
	csrfKey string

	// Path to kubeconfig file. If both kubeConfigPath and apiserverHost are
	// empty inClusterConfig will be used
	kubeConfigPath string

	// Address of apiserver host in format 'protocol://address:port'
	apiserverHost string

	// Initialized on clientManager creation and used if kubeconfigPath and
	// apiserverHost are empty
	inClusterConfig *rest.Config

	// Responsible for decrypting tokens coming in request header. Used for
	// authentication.
	tokenManager authAPI.TokenManager

	// Kubernetes client created without providing auth info. It uses
	// permissions granted to service account used by dashboard or kubeconfig
	// file if it was passed during dashboard init.
	insecureClient kubernetes.Interface

	insecureConfig *rest.Config
}

// Dashboard UI default values for client configs.
const (
	// High enough QPS to fit all expected use cases. QPS=0 is not set here, because
	// client code is overriding it.
	DefaultQPS = 1e6

	// High enough Burst to fit all expected use cases. Burst=0 is not set here, because
	// client code is overriding it.
	DefaultBurst = 1e6

	// Use kubernetes protobuf as content type by default
	DefaultContentType = "application/vnd.kubernetes.protobuf"

	// Default cluster/context/auth name to be set in clientcmd config
	DefaultCmdConfigName = "kubernetes"

	// Header name that contains token used for authorization. See TokenManager for more information.
	JWETokenHeader = "jweToken"

	// Default http header for user-agent
	DefaultUserAgent = "flexui"
)

// Client returns a kubernetes client. In case dashboard login is enabled and
// option to skip login page is disabled only secure client will be returned,
// otherwise insecure client will be used.
func (c *clientManager) Client(req *restful.Request) (kubernetes.Interface, error) {
	if req == nil {
		return nil, errors.New("request can not be nil")
	}
	return c.secureClient(req)
}

// Config returns a rest config. In case dashboard login is enabled and option
// to skip login page is disabled only secure config will be returned, otherwise
// insecure config will be used.
func (c *clientManager) Config(req *restful.Request) (*rest.Config, error) {
	if req == nil {
		return nil, errors.New("request can not be nil")
	}
	return c.secureConfig(req)
}

// CanI returns true when user is allowed to access data provided within
// SelfSubjectAccessReview, false otherwise.
func (c *clientManager) CanI(req *restful.Request, ssar *authv1.SelfSubjectAccessReview) bool {
	client, err := c.Client(req)
	if err != nil {
		log.Println(err)
		return false
	}

	response, err := client.AuthorizationV1().SelfSubjectAccessReviews().Create(ssar)
	if err != nil {
		log.Println(err)
		return false
	}

	return response.Status.Allowed
}

// ClientCmdConfig creates ClientCmd Config based on authentication information
// extracted from request. Currently request header is only checked for
// existence of 'Authentication: BearerToken'
func (c *clientManager) ClientCmdConfig(req *restful.Request) (clientcmd.ClientConfig, error) {
	authInfo, err := c.extractAuthInfo(req)
	if err != nil {
		return nil, err
	}
	cfg, err := c.buildConfigFromFlags(c.apiserverHost, c.kubeConfigPath)
	if err != nil {
		return nil, err
	}
	return c.buildCmdConfig(*authInfo, cfg), nil
}

// CSRFKey returns key that is generated upon client manager creation
func (c *clientManager) CSRFKey() string {
	return c.csrfKey
}

// HasAccess configures K8S api client with provided auth info and executes a
// basic check against api-server to see if it is valid.
func (c *clientManager) HasAccess(authInfo cmdAPI.AuthInfo) error {
	cfg, err := c.buildConfigFromFlags(c.apiserverHost, c.kubeConfigPath)
	if err != nil {
		return err
	}

	clientConfig := c.buildCmdConfig(authInfo, cfg)
	cfg, err = clientConfig.ClientConfig()
	if err != nil {
		return err
	}

	client, err := kubernetes.NewForConfig(cfg)
	if err != nil {
		return err
	}

	_, err = client.ServerVersion()
	return err
}

// SetTokenManager sets the token manager that will be used for token decryption.
func (c *clientManager) SetTokenManager(manager authAPI.TokenManager) {
	c.tokenManager = manager
}

// Initializes config with default values
func (c *clientManager) initConfig(cfg *rest.Config) {
	cfg.QPS = DefaultQPS
	cfg.Burst = DefaultBurst
	cfg.ContentType = DefaultContentType
	cfg.UserAgent = DefaultUserAgent + "/" + Version
}

// Returns rest Config based on provided apiserverHost and kubeConfigPath flags. If both are
// empty then in-cluster config will be used and if it is nil the error is returned.
func (c *clientManager) buildConfigFromFlags(apiserverHost, kubeConfigPath string) (
	*rest.Config, error) {
	if len(kubeConfigPath) > 0 || len(apiserverHost) > 0 {
		return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
			&clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeConfigPath},
			&clientcmd.ConfigOverrides{ClusterInfo: cmdAPI.Cluster{Server: apiserverHost}}).ClientConfig()
	}

	if c.isRunningInCluster() {
		return c.inClusterConfig, nil
	}

	return nil, errors.New("could not create client config")
}

// Returns true if in-cluster config is used
func (c *clientManager) isRunningInCluster() bool {
	return c.inClusterConfig != nil
}

// Based on auth info and rest config creates client cmd config.
func (c *clientManager) buildCmdConfig(authInfo cmdAPI.AuthInfo, cfg *rest.Config) clientcmd.ClientConfig {
	cmdCfg := cmdAPI.NewConfig()
	cmdCfg.Clusters[DefaultCmdConfigName] = &cmdAPI.Cluster{
		Server:                   cfg.Host,
		CertificateAuthority:     cfg.TLSClientConfig.CAFile,
		CertificateAuthorityData: cfg.TLSClientConfig.CAData,
		InsecureSkipTLSVerify:    cfg.TLSClientConfig.Insecure,
	}
	cmdCfg.AuthInfos[DefaultCmdConfigName] = &authInfo
	cmdCfg.Contexts[DefaultCmdConfigName] = &cmdAPI.Context{
		Cluster:  DefaultCmdConfigName,
		AuthInfo: DefaultCmdConfigName,
	}
	cmdCfg.CurrentContext = DefaultCmdConfigName

	return clientcmd.NewDefaultClientConfig(
		*cmdCfg,
		&clientcmd.ConfigOverrides{},
	)
}

// Extracts authorization information from the request header
func (c *clientManager) extractAuthInfo(req *restful.Request) (*cmdAPI.AuthInfo, error) {
	authHeader := req.HeaderParameter("Authorization")
	jweToken := req.HeaderParameter(JWETokenHeader)

	// Authorization header will be more important than our token
	token := c.extractTokenFromHeader(authHeader)
	if len(token) > 0 {
		return &cmdAPI.AuthInfo{Token: token}, nil
	}

	if c.tokenManager != nil && len(jweToken) > 0 {
		token, err := c.tokenManager.Decrypt(jweToken)
		if err != nil {
			return nil, err
		}
		return token, nil
	}

	return nil, k8serrors.NewUnauthorized(MsgLoginUnauthorizedError)
}

func (c *clientManager) extractTokenFromHeader(authHeader string) string {
	if strings.HasPrefix(authHeader, "Bearer ") {
		return strings.TrimPrefix(authHeader, "Bearer ")
	}

	return ""
}

func (c *clientManager) secureClient(req *restful.Request) (kubernetes.Interface, error) {
	cfg, err := c.secureConfig(req)
	if err != nil {
		return nil, err
	}

	client, err := kubernetes.NewForConfig(cfg)
	if err != nil {
		return nil, err
	}

	return client, nil
}

func (c *clientManager) secureConfig(req *restful.Request) (*rest.Config, error) {
	cmdConfig, err := c.ClientCmdConfig(req)
	if err != nil {
		return nil, err
	}

	cfg, err := cmdConfig.ClientConfig()
	if err != nil {
		return nil, err
	}

	c.initConfig(cfg)
	return cfg, nil
}

// Initializes client manager
func (c *clientManager) init() {
	c.initInClusterConfig()
	c.initInsecureClient()
	c.initCSRFKey()
}

func (c *clientManager) initInsecureConfig() {
	cfg, err := c.buildConfigFromFlags(c.apiserverHost, c.kubeConfigPath)
	if err != nil {
		logrus.Fatal(err)
	}
	c.insecureConfig = cfg
}

// Initializes in-cluster config if apiServerHost and kubeConfigPath were not provided.
func (c *clientManager) initInClusterConfig() {
	if len(c.apiserverHost) > 0 || len(c.kubeConfigPath) > 0 {
		log.Print("Skipping in-cluster config")
		return
	}

	log.Print("Using in-cluster config to connect to apiserver")
	cfg, err := rest.InClusterConfig()
	if err != nil {
		log.Printf("Could not init in cluster config: %s", err.Error())
		return
	}

	c.inClusterConfig = cfg
}

func (c *clientManager) initInsecureClient() {
	c.initInsecureConfig()
	client, err := kubernetes.NewForConfig(c.insecureConfig)
	if err != nil {
		logrus.Fatal(err)
	}

	c.insecureClient = client
}

// NewClientManager creates client manager based on kubeConfigPath and apiserverHost parameters.
// If both are empty then in-cluster config is used.
func NewClientManager(kubeConfigPath, apiserverHost string) api.ClientManager {
	result := &clientManager{
		kubeConfigPath: kubeConfigPath,
		apiserverHost:  apiserverHost,
	}
	result.init()
	return result
}

// Initializes csrfKey. If in-cluster config is detected then csrf key is
// initialized with service account token, otherwise it is generated
func (c *clientManager) initCSRFKey() {
	if c.inClusterConfig == nil {
		// Most likely running for a dev, so no replica issues, just generate a
		// random key
		log.Println("Using random key for csrf signing")
		c.csrfKey = api.GenerateCSRFKey()
		return
	}
	// We run in a cluster, so we should use a signing key that is the same for
	// potential replications
	log.Println("Using secret token for csrf signing")
	c.csrfKey = csrf.NewCSRFTokenManager(c.insecureClient).Token()
}

var _ api.ClientManager = (*clientManager)(nil)
